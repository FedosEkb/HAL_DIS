/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */


#include "main.h"

/* data declaration */

/* SPI handle for our SPI device */
spi_handle_t SpiHandle;

int TestReady = 0;

uint8_t master_write_data[4]={ 0xa, 0xb, 0xc, 0xd};

uint8_t slave_tx_buffer[4]={ 0x55, 0xaa, 0x55, 0xaa};
uint8_t slave_rx_buffer[4];


int main(void)


{
	uint16_t ack_bytes = SPI_ACK_BYTES;
	uint8_t rcv_cmd[2];
	uint8_t ack_buf[2] = { 0XD5, 0XE5 };
	uint16_t master_cmd;

	spi_gpio_init();


	led_init();  										// configure LED


	/* Configure USER Button as ext interrupt throw EXTI0 */

	_HAL_RCC_GPIOA_CLK_ENABLE();
	gpio_pin_conf_t gpio_pin_conf;
	gpio_pin_conf.pin = GPIO_BUTTON_PIN;
	gpio_pin_conf.mode = GPIO_PIN_INPUT_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_NO_PULL_PUSH;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;
	hal_gpio_init(GPIO_BUTTON_PORT,&gpio_pin_conf);


	//RCC->APB2ENR |= (1 << 14);
	//SYSCFG->EXTICR[0] &= (0b1111 << 12);
	hal_gpio_configure_interrupt(GPIO_BUTTON_PIN, INT_FALLING_EDGE);
	hal_gpio_enable_interrupt(GPIO_BUTTON_PIN, EXTI0_IRQn);

	_HAL_RCC_SPI2_CLK_ENABLE();


	/*fill up the SPI handle structure */
	SpiHandle.Instance				= SPI_2;

	SpiHandle.Init.BaudRatePrescaler = SPI_REG_CR1_BR_PCLK_DIV_32;
	SpiHandle.Init.Direction         = SPI_ENABLE_2_LINE_UNI_DIR;
	SpiHandle.Init.CLKPhase          = SPI_SECOND_CLOCK_TRANS;
	SpiHandle.Init.CLKPolarity       = SPI_CPOL_LOW;
	SpiHandle.Init.DataSize          = SPI_8BIT_DF_ENABLE;
	SpiHandle.Init.FirstBit          = SPI_MSB_FIRST;
	SpiHandle.Init.NSS               = SPI_SSM_ENABLE;
	SpiHandle.Init.Mode              = SPI_SLAVE_MODE_SEL;

	SpiHandle.State = HAL_SPI_STATE_READY;

	/* Call driver API to initialize the SPI device */
	hal_spi_init(&SpiHandle);

	/* Enable the IRQs in the NVIC */
	NVIC_EnableIRQ(SPI2_IRQn);

	/* Wait for user Button press before starting the communication. Toggles LED_ORANGE until then */
	/*while (TestReady != SET) {
		led_toggle(GPIOD, LED_RED);
		//LED3 (orange)
		delay_gen();
	}*/
	hal_gpio_write_to_pin(GPIOI, LED_RED, 0);

	while (1) {
		/*Make sure that driver state is ready */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* Receive the master command first */
		hal_spi_slave_rx(&SpiHandle, rcv_cmd, CMD_LENGTH);

		/* wait until driver finishes RXing and state becomes ready again */
		while (SpiHandle.State != HAL_SPI_STATE_READY)
			;

		/* This is the command slave got */
		master_cmd = (uint16_t) (rcv_cmd[1] << 8 | rcv_cmd[0]);

		/* is it a valid command ? */
		if (master_cmd == CMD_MASTER_WRITE || master_cmd == CMD_MASTER_READ) {
			/* yes, send out the ACK bytes */
			hal_spi_slave_tx(&SpiHandle, (uint8_t*) &ack_buf, ACK_LEN);
			while (SpiHandle.State != HAL_SPI_STATE_READY)
				;

		} else {
			/*  No, Error !*/
			led_toggle(GPIOD, LED_RED);
		}

		/* is it a write command from master ? */
		if (master_cmd == CMD_MASTER_WRITE) {
			/* master wants to write, so get ready to receive the data */
			hal_spi_slave_rx(&SpiHandle, slave_rx_buffer, DATA_LENGTH);

			/* wait until the recepion completes */
			while (SpiHandle.State != HAL_SPI_STATE_READY)
				;

			/* compare the received data with the expected data */
			if (Buffercmp(master_write_data, slave_rx_buffer, 4)) {
				/* doesnt match Error ! */
				led_toggle(GPIOD, LED_RED);
			} else {
				/*matches , tOggle the blue LED */
				led_toggle(GPIOD, LED_BLUE);
			}
		}

		/*  or, is it a read command from master ?*/
		if (master_cmd == CMD_MASTER_READ) {
			/* master wants to read, so transmit data to master  */
			hal_spi_slave_tx(&SpiHandle, slave_tx_buffer, DATA_LENGTH);

			/* hang on , till the TXing finishes */
			while (SpiHandle.State != HAL_SPI_STATE_READY)
				;
		}

	}
	return 0;
}

void delay_gen(void) {
	uint32_t cnt = 800000;
	while (cnt--)
		;
}

void led_init(void){
	gpio_pin_conf_t gpio_pin_conf;

	_HAL_RCC_GPIOD_CLK_ENABLE();
	gpio_pin_conf.pin = LED_RED;
	gpio_pin_conf.mode = GPIO_PIN_OUTPUT_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_NO_PULL_PUSH;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;
	hal_gpio_init(GPIOD,&gpio_pin_conf);

	gpio_pin_conf.pin = LED_BLUE;
	hal_gpio_init(GPIOD, &gpio_pin_conf);

	gpio_pin_conf.pin = LED_ORANGE;
	hal_gpio_init(GPIOD, &gpio_pin_conf);

	gpio_pin_conf.pin = LED_GREEN;
	hal_gpio_init(GPIOD, &gpio_pin_conf);

}

void led_toggle(GPIO_TypeDef *GPIOx, uint16_t pin) {
	if (hal_gpio_read_from_pin(GPIOx, pin))
		hal_gpio_write_to_pin(GPIOx, pin, 0);
	else
		hal_gpio_write_to_pin(GPIOx, pin, 1);
}

void spi_gpio_init(void){
	gpio_pin_conf_t gpio_pin_conf;

	_HAL_RCC_GPIOB_CLK_ENABLE();

	/* configure GPIOI_PIN_1 for SPI CLK functionality */
	gpio_pin_conf.pin = SPI_CLK_PIN;
	gpio_pin_conf.mode = GPIO_PIN_ALT_FUN_MODE;
	gpio_pin_conf.op_type = GPIO_PIN_OP_TYPE_PUSHPULL;
	gpio_pin_conf.pull = GPIO_PIN_PUSH_DOWN;
	gpio_pin_conf.speed = GPIO_PIN_SPEED_MEDIUM;

	hal_gpio_set_alt_function(GPIOB, SPI_CLK_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOB,&gpio_pin_conf);

	/* configure GPIOI_PIN_2 for SPI MISO functionality */
	gpio_pin_conf.pin = SPI_MISO_PIN;
	gpio_pin_conf.pull = GPIO_PIN_PULL_UP;

	hal_gpio_set_alt_function(GPIOB, SPI_MISO_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOB, &gpio_pin_conf);

	/* configure GPIOI_PIN_3 for SPI MISO functionality */
	gpio_pin_conf.pin = SPI_MOSI_PIN;
	gpio_pin_conf.pull = GPIO_PIN_PULL_UP;

	hal_gpio_set_alt_function(GPIOB, SPI_MOSI_PIN, GPIO_PIN_AF5_SPI2);
	hal_gpio_init(GPIOB, &gpio_pin_conf);
}

void assert_error(void) {
	while (1) {
		led_toggle(GPIOD, LED_RED);
		delay_gen();
	}
}

static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
{
  while (BufferLength--)
  {
    if((*pBuffer1) != *pBuffer2)
    {
      return BufferLength;
    }
    pBuffer1++;
    pBuffer2++;
  }
	return 0;
}

/*
 * @brief  brief  This function handles EXTI15-10 interrupt request.
 * @param  none
 * @retval none
 */
void EXTI0_IRQHandler(void){
	hal_gpio_clear_interrupt(GPIO_BUTTON_PIN);
	TestReady = SET;
}

/*
 * @brief  This function handles SPI2 interrupt request.
 * @param  none
 * @retval none
 */
void SPI2_IRQHandler(void) {
	/* call the driver api to process this interrupt */
	hal_spi_irq_handler(&SpiHandle);
}




